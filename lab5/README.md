## 1. Введение

### 1.1. Цель документа
Настоящий документ описывает архитектуру и ключевые проектные решения, принятые при разработке клиент-серверного приложения в соответствии с техническим заданием. Цель — предоставить ясное понимание структуры системы, её компонентов, их взаимодействия и обоснования выбранного подхода.

### 1.2. Обзор системы
Система представляет собой классическое клиент-серверное приложение, работающее по протоколу TCP/IP.

*   **Клиент** запрашивает у пользователя целое число, устанавливает соединение с сервером, отправляет ему свое имя и введенное число. Затем клиент ожидает ответ, обрабатывает его и выводит сводную информацию на экран.
*   **Сервер** работает в режиме ожидания, принимая подключения от клиентов. Для каждого клиента он получает данные, выполняет вычисления, выводит информацию в свою консоль и отправляет ответный пакет данных клиенту. Сервер имеет механизм грациозного завершения работы, который инициируется клиентом.

## 2. Архитектурный обзор

Система построена на основе **клиент-серверной архитектуры** с четким разделением ролей. Взаимодействие между компонентами осуществляется по сети с использованием сокетов. В качестве транспортного протокола выбран **TCP**, так как он обеспечивает надежную, ориентированную на соединение доставку данных.

Сервер реализован по **итеративной модели**: он обрабатывает клиентские подключения последовательно, одно за другим, что полностью соответствует требованиям задания.

## 3. Компоненты системы

Система декомпозирована на несколько логических компонентов, каждый из которых имеет четко определенную зону ответственности.

### 3.1. Основное приложение (`main.cpp`)
Является точкой входа. Его задача - разобрать аргументы командной строки (`server` или `client`) и запустить соответствующий компонент (`TcpServer` или `TcpClient`).

### 3.2. Компонент "Сервер" (`TcpServer`)
**Ответственность:** Управление жизненным циклом сервера.
*   **Инициализация:** В конструкторе принимаются порт и имя сервера.
*   **Настройка сокета (`setupSocket`):** Выполняет системные вызовы `socket()`, `bind()` и `listen()`.
*   **Главный цикл (`run`):** В бесконечном цикле ожидает подключения с помощью блокирующего вызова `accept()`.
*   **Обработка клиента (`handleClient`):** Выполняет логику сеанса: **напрямую получает пакет с помощью `recv()`**, выводит информацию, формирует и **отправляет ответный пакет с помощью `send()`**. Здесь же реализована логика проверки числа для остановки сервера.
*   **Освобождение ресурсов:** Деструктор класса корректно закрывает слушающий сокет (`close()`).

### 3.3. Компонент "Клиент" (`TcpClient`)
**Ответственность:** Реализация логики работы клиентской стороны.
*   **Инициализация:** В конструкторе принимаются IP-адрес и порт сервера, а также имя клиента.
*   **Установка соединения (`connectToServer`):** Создает сокет и устанавливает TCP-соединение с помощью `connect()`.
*   **Основной сценарий (`run`):** Оркестрирует всю последовательность действий: **формирует пакет, отправляет его с помощью `send()`, ожидает ответ с помощью `recv()`**, выводит информацию и закрывает сокет.

### 3.4. Протокол обмена данными

**Протокол обмена данными был сознательно упрощен** для демонстрации прямого использования системных вызовов `send()` и `recv()`, как того требовало задание. Взаимодействие основано на передаче структуры фиксированного размера.

#### 3.4.1. Структура данных (`CommunicationPacket.h`)
Для инкапсуляции передаваемых данных определена простая C-style структура `CommunicationPacket`.
```cpp
const int MAX_NAME_LENGTH = 128;

struct CommunicationPacket {
    char name[MAX_NAME_LENGTH];
    int32_t number;
};
```
Использование массива `char` фиксированного размера вместо `std::string` гарантирует, что размер структуры всегда одинаков. Это позволяет отправлять и получать ее как единый непрерывный блок байтов.

#### 3.4.2. Процесс передачи данных
Вместо отдельного модуля сериализации, **клиент и сервер работают со структурой напрямую**:
1.  Отправляющая сторона заполняет поля структуры `CommunicationPacket`.
2.  Числовое поле `number` преобразуется в сетевой порядок байтов с помощью `htonl()`.
3.  Вызывается системный вызов `send()`, которому передается указатель на структуру и ее размер (`sizeof(CommunicationPacket)`).
4.  Принимающая сторона вызывает `recv()` для чтения ровно `sizeof(CommunicationPacket)` байт в свою локальную структуру.
5.  Полученное числовое поле преобразуется обратно в хостовый порядок байтов с помощью `ntohl()`.

Этот подход прост, надежен для данной задачи и напрямую демонстрирует понимание работы с `send()` и `recv()`.

## 4. Ключевые проектные решения и их обоснование

1.  **Модульная архитектура на C++:**
    *   **Решение:** Код разделен на классы (`TcpClient`, `TcpServer`), инкапсулирующие логику клиента и сервера.
    *   **Обоснование:** Несмотря на простоту протокола, использование классов позволяет структурировать код, управлять ресурсами (сокеты закрываются в деструкторах) и сделать его более читаемым и поддерживаемым, чем монолитный C-style код.

2.  **Простой протокол на основе структуры фиксированного размера:**
    *   **Решение:** Вместо протокола с динамической длиной полей была выбрана простая C-style структура `CommunicationPacket`.
    *   **Обоснование:** Это решение является прямым ответом на требование продемонстрировать базовую работу с `send()`/`recv()`. Оно избавляет от необходимости управлять буферами и обрабатывать частичные чтения/записи, что позволяет сфокусироваться на основной логике задания.

3.  **Использование структуры для инкапсуляции данных:**
    *   **Решение:** Данные (имя и число) объединены в структуру `CommunicationPacket`.
    *   **Обоснование:** Повышает читаемость кода (мы передаем "пакет", а не отдельные переменные), снижает вероятность ошибок и упрощает отладку.

4.  **Обработка ошибок:**
    *   **Решение:** Критические ошибки на этапе инициализации (невозможность создать сокет или привязать порт) приводят к выбросу исключений `std::runtime_error`. Ошибки во время обмена данными (`send`/`recv`) обрабатываются проверкой возвращаемого значения, а для вывода системного сообщения об ошибке используется `perror()`.
    *   **Обоснование:** Такой гибридный подход является стандартной практикой. Исключения сигнализируют о фатальных сбоях на старте, в то время как проверка кодов возврата является стандартным способом обработки ошибок ввода-вывода в работающем приложении.

## 5. Заключение

Представленная архитектура полностью удовлетворяет требованиям технического задания, включая устные уточнения. Она использует объектно-ориентированный подход языка C++ для структурирования кода, но при этом реализует **простой и ясный протокол передачи данных, напрямую используя базовые системные вызовы `send()` и `recv()`**, что демонстрирует понимание основ сетевого программирования.