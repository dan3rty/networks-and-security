## 1. Введение

### 1.1. Цель документа
Настоящий документ описывает архитектуру и ключевые проектные решения, принятые при разработке клиент-серверного приложения в соответствии с техническим заданием. Цель — предоставить ясное понимание структуры системы, её компонентов, их взаимодействия и обоснования выбранного подхода.

### 1.2. Обзор системы
Система представляет собой классическое клиент-серверное приложение, работающее по протоколу TCP/IP.

*   **Клиент** запрашивает у пользователя целое число, устанавливает соединение с сервером, отправляет ему свое имя и введенное число. Затем клиент ожидает ответ, обрабатывает его и выводит сводную информацию на экран.
*   **Сервер** работает в режиме ожидания, принимая подключения от клиентов. Для каждого клиента он получает данные, выполняет вычисления, выводит информацию в свою консоль и отправляет ответный пакет данных клиенту. Сервер имеет механизм грациозного завершения работы, который инициируется клиентом.

## 2. Архитектурный обзор

Система построена на основе **клиент-серверной архитектуры** с четким разделением ролей. Взаимодействие между компонентами осуществляется по сети с использованием сокетов. В качестве транспортного протокола выбран **TCP**, так как он обеспечивает надежную, ориентированную на соединение доставку данных, что является необходимым условием для гарантированного обмена сообщениями.

Сервер реализован по **итеративной модели**: он обрабатывает клиентские подключения последовательно, одно за другим.

## 3. Компоненты системы

Система декомпозирована на несколько логических компонентов, каждый из которых имеет четко определенную зону ответственности.

### 3.1. Основное приложение (`main.cpp`)
Является точкой входа. Его единственная задача - разобрать аргументы командной строки (`server` или `client`) и запустить соответствующий компонент (`TcpServer` или `TcpClient`), передав ему необходимые параметры конфигурации (IP-адрес, порт).

### 3.2. Компонент "Сервер" (`TcpServer`)
**Ответственность:** Управление жизненным циклом сервера.
*   **Инициализация:** В конструкторе принимаются порт и имя сервера.
*   **Настройка сокета (`setupSocket`):** Выполняет системные вызовы `socket()`, `bind()` и `listen()` для подготовки слушающего сокета к приему подключений. Используется опция `SO_REUSEADDR` для удобства перезапуска сервера.
*   **Главный цикл (`run`):** В бесконечном цикле ожидает подключения с помощью блокирующего вызова `accept()`. После успешного подключения передает управление для обработки конкретного клиента.
*   **Обработка клиента (`handleClient`):** Выполняет всю логику для одного клиентского сеанса: получение пакета, вывод информации в консоль, формирование и отправка ответного пакета. Здесь же реализована логика проверки числа для остановки сервера (`m_shouldStop`).
*   **Освобождение ресурсов:** Деструктор класса корректно закрывает слушающий сокет.

### 3.3. Компонент "Клиент" (`TcpClient`)
**Ответственность:** Реализация логики работы клиентской стороны.
*   **Инициализация:** В конструкторе принимаются IP-адрес и порт сервера, а также имя клиента.
*   **Ввод данных (`getUserInput`):** Обеспечивает корректный ввод целого числа от пользователя.
*   **Установка соединения (`connectToServer`):** Создает сокет и устанавливает TCP-соединение с сервером с помощью вызова `connect()`.
*   **Основной сценарий (`run`):** Оркестрирует всю последовательность действий клиента: получение ввода, установка соединения, отправка пакета, ожидание ответа, вывод информации и закрытие сокета.

### 3.4. Протокол обмена данными

Для обеспечения надежного и предсказуемого обмена данными между клиентом и сервером был разработан специальный модуль протокола.

#### 3.4.1. Структура данных (`DataPacket.h`)
Для инкапсуляции передаваемых данных определена структура `DataPacket`.
```cpp
struct DataPacket {
    std::string senderName;
    int32_t number;
};
```
Использование этой структуры вместо передачи разрозненных переменных делает код более читаемым, типизированным и легко расширяемым в будущем.

#### 3.4.2. Модуль сериализации/десериализации (`PacketProtocol`)
**Ответственность:** Преобразование структуры `DataPacket` в поток байт для отправки по сети (сериализация) и обратное преобразование (десериализация). Этот модуль полностью изолирует логику клиента и сервера от деталей сетевого формата.

**Формат сообщения:**
1.  Длина имени (`uint32_t`, 4 байта) в сетевом порядке байтов.
2.  Строка с именем (N байт, без `\0` на конце).
3.  Число (`int32_t`, 4 байта) в сетевом порядке байтов.

Для корректной работы на системах с разным порядком байтов (endianness) используются функции `htonl()` и `ntohl()`. Для гарантированной отправки и получения точного числа байт реализованы вспомогательные функции `sendExactly()` и `receiveExactly()`, которые обрабатывают частичные операции чтения/записи стандартных `send()`/`recv()`.

## 4. Ключевые проектные решения и их обоснование

1.  **Модульная архитектура с разделением ответственности (SoC):**
    *   **Решение:** Код разделен на классы (`TcpClient`, `TcpServer`) и логические модули (`PacketProtocol`).
    *   **Обоснование:** Такой подход упрощает понимание, тестирование и модификацию кода. Каждый компонент решает только свою задачу: `TcpServer` не знает, как устроен пакет, он просто просит `PacketProtocol` его отправить.

2.  **Выделенный модуль протокола:**
    *   **Решение:** Вся логика по работе с форматом сообщений вынесена в `PacketProtocol`.
    *   **Обоснование:** Это делает систему гибкой. Если в будущем потребуется изменить протокол (например, добавить сжатие, шифрование или новые поля), изменения потребуется внести только в одном месте, не затрагивая основную логику клиента и сервера.

3.  **Использование структуры для передачи данных:**
    *   **Решение:** Вместо передачи `string` и `int` по отдельности используется структура `DataPacket`.
    *   **Обоснование:** Повышает читаемость кода, снижает вероятность ошибок (например, перепутать порядок отправки полей) и упрощает добавление новых данных в будущем.

4.  **Обработка ошибок:**
    *   **Решение:** Критические ошибки на этапе инициализации (невозможность создать сокет или привязать порт) приводят к выбросу исключений `std::runtime_error`. Ошибки во время обмена данными (например, разрыв соединения) обрабатываются через возвращаемые значения (`bool`) функций протокола.
    *   **Обоснование:** Исключения сигнализируют о невозможности продолжения работы программы в штатном режиме, что является корректным поведением при ошибках инициализации. Возвращаемые значения удобны для обработки ожидаемых сбоев в цикле работы.

## 5. Заключение

Представленная архитектура полностью удовлетворяет требованиям технического задания. Она является модульной, расширяемой и использует стандартные подходы к сетевому программированию на C++. Разделение логики на компоненты и четко определенный протокол обмена данными обеспечивают надежность и простоту сопровождения разработанного решения.