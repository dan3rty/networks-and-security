# Документ по проектированию: Протокол надежной передачи данных (RDTP)

---

## 1. Введение

Целью данной работы является разработка и реализация протокола надежной передачи данных (RDTP — Reliable Data Transfer Protocol) поверх ненадежного транспорта UDP.

Протокол должен гарантировать доставку файла от отправителя к получателю без ошибок, потерь и нарушения порядка следования пакетов, несмотря на эмуляцию нестабильной сетевой среды (потери пакетов). В качестве основного алгоритма управления потоком и ошибками выбран **Go-Back-N (GBN)**.

### Архитектура
Система строится по архитектуре "Клиент-Сервер":
*   **Sender (Клиент/Отправитель):** Инициирует передачу, разбивает файл на сегменты, управляет окном передачи и таймерами.
*   **Receiver (Сервер/Получатель):** Ожидает пакеты, проверяет их порядок, собирает файл и отправляет подтверждения (ACK).

---

## 2. Формат пакета (Packet Structure)

Для обмена данными между клиентом и сервером используется единая структура пакета фиксированного максимального размера. Пакет инкапсулируется в датаграмму UDP.

### Определение структуры (C/C++)
```cpp
struct Packet {
    uint32_t seq_num;   // Номер последовательности (4 байта)
    uint32_t ack_num;   // Номер подтверждения (4 байта)
    uint8_t  flags;     // Флаги управления (1 байт)
    uint16_t data_size; // Размер полезных данных (2 байта)
    char     data[MSS]; // Полезная нагрузка (1024 байта)
};
```

### Описание полей

| Поле            | Размер     | Описание                                                                                                                                                                                             |
|:----------------|:-----------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **`seq_num`**   | 4 байта    | **Sequence Number.** Уникальный порядковый номер пакета. Используется получателем для сборки файла в правильном порядке и обнаружения потерь.                                                        |
| **`ack_num`**   | 4 байта    | **Acknowledgment Number.** Используется получателем для подтверждения успешного приема пакетов. В GBN используется кумулятивное подтверждение (ACK $N$ подтверждает все пакеты до $N$ включительно). |
| **`flags`**     | 1 байт     | **Тип пакета.**<br> `0 (FLAG_DATA)`: Пакет с данными файла.<br> `1 (FLAG_ACK)`: Пакет подтверждения.<br> `2 (FLAG_FIN)`: Сигнал завершения передачи.                                                 |
| **`data_size`** | 2 байта    | Реальное количество байт в поле `data`. Может быть меньше MSS (например, для последнего пакета файла).                                                                                               |
| **`data`**      | 1024 байта | **Payload.** Сами передаваемые данные (часть файла).                                                                                                                                                 |

---

## 3. Выбранные алгоритмы и механизмы

### 3.1. Go-Back-N (GBN)
Выбран алгоритм **Go-Back-N** (Возврат на N) из-за его простоты реализации на стороне получателя и эффективности в сетях с умеренным количеством ошибок.

*   **Принцип окна:** Отправителю разрешено отправить несколько пакетов (размер окна $N$) без получения подтверждения.
*   **Кумулятивный ACK:** Получатель отправляет ACK только для пакетов, пришедших строго по порядку. Если ожидается пакет $K$, а пришел $K+1$, получатель отбрасывает $K+1$ и повторно отправляет ACK для $K-1$.
*   **Групповая повторная передача:** При истечении тайм-аута (если ACK для самого старого пакета в окне не получен) отправитель повторно посылает **все** неподтвержденные пакеты в текущем окне.

### 3.2. Скользящее окно (Sliding Window)
*   **Размер окна (`WINDOW_SIZE`):** Фиксирован (в текущей реализации равен 5).
*   **Переменные отправителя:**
    *   `base`: Номер последовательности самого старого неподтвержденного пакета.
    *   `next_seq_num`: Номер последовательности следующего пакета для отправки.
*   **Условие отправки:** Отправка разрешена, только если `next_seq_num < base + WINDOW_SIZE`.

### 3.3. Обработка тайм-аутов
Используется системный вызов `select()` для неблокирующего ожидания ответов от сокета.
*   Таймер запускается для пакета `base`.
*   Если приходит ACK для `base`, окно сдвигается, и таймер перезапускается для нового `base`.
*   Если время ожидания истекает, происходит событие `TIMEOUT`, и вызывается процедура повторной передачи всего окна.

---

## 4. Конечный автомат (Finite State Machine)

Ниже описаны состояния и переходы для Отправителя и Получателя.

### 4.1. FSM Отправителя (Sender)

Отправитель имеет сложную логику, обрабатывающую события от прикладного уровня (чтение файла) и сетевого уровня (получение ACK, тайм-аут).

**Состояния:**
1.  **WAIT_FOR_CALL:** Ожидание возможности отправить данные (проверка окна).
2.  **WAIT_FOR_ACK:** Ожидание подтверждений от получателя.

**Логика переходов:**

*   **Событие: Есть данные для отправки**
    *   *Условие:* `next_seq_num < base + WINDOW_SIZE`
    *   *Действие:* Создать пакет с `seq_num = next_seq_num`. Отправить пакет через UDP. Инкрементировать `next_seq_num`. Если это первый пакет в окне (`base == next_seq_num`), запустить таймер.

*   **Событие: Истечение тайм-аута (Timeout)**
    *   *Действие:* Переотправить **все** пакеты в диапазоне `[base, next_seq_num - 1]`. Перезапустить таймер.

*   **Событие: Получен пакет ACK (с номером `ack_pkt.ack_num`)**
    *   *Условие:* `ack_pkt.ack_num >= base` (Новое подтверждение)
    *   *Действие:*
        1.  Сдвинуть окно: `base = ack_pkt.ack_num + 1`.
        2.  Если `base == next_seq_num` (все отправленные подтверждены): Остановить таймер.
        3.  Иначе (есть еще неподтвержденные): Перезапустить таймер.
    *   *Условие:* `ack_pkt.flags == FLAG_FIN`
    *   *Действие:* Завершить работу.

### 4.2. FSM Получателя (Receiver)

Логика получателя в GBN предельно проста (Simple Receiver), так как он не буферизует пакеты "из будущего".

**Переменные:**
*   `expected_seq`: Номер пакета, который ожидается следующим (инициализируется 0).

**Логика переходов:**

*   **Событие: Получен пакет DATA (с номером `pkt.seq_num`)**
    *   *Случай 1: `pkt.seq_num == expected_seq` (Пакет пришел по порядку)*
        *   *Действие:*
            1.  Извлечь данные и записать в файл.
            2.  Отправить `ACK` с номером `expected_seq`.
            3.  Инкрементировать `expected_seq`.
    *   *Случай 2: `pkt.seq_num != expected_seq` (Ошибка порядка или дубликат)*
        *   *Действие:*
            1.  Отбросить пакет (Discard).
            2.  Отправить дублирующий `ACK` для последнего успешно принятого пакета (`expected_seq - 1`).

*   **Событие: Получен пакет FIN**
    *   *Действие:* Отправить `ACK` для FIN. Закрыть файл. Завершить работу.

---

## 5. Обработка ошибок и симуляция ненадежности

Для проверки надежности протокола в код `Sender` встроена программная симуляция ошибок.

### 5.1. Симуляция потерь (Traffic Shaping)
Перед вызовом `sendto()` выполняется проверка:
```cpp
if (rand() % 100 < LOSS_RATE) {
    // Пакет "теряется" (не отправляется в сокет), но
    // логика программы считает его отправленным.
    return;
}
```
Это заставляет `Receiver` не получать ожидаемый пакет, что провоцирует отправку дублирующих ACK, а `Sender` — уходить в Timeout.

### 5.2. Сценарий восстановления (Пример)
1.  Окно `[0, 1, 2, 3, 4]`. Sender отправляет 0, 1, 2, 3, 4.
2.  Пакет №1 теряется.
3.  Receiver получает 0 -> `ACK 0`. Ждет 1.
4.  Receiver получает 2 -> Не 1 -> Отбрасывает -> `ACK 0`.
5.  Receiver получает 3 -> Не 1 -> Отбрасывает -> `ACK 0`.
6.  ...
7.  Sender получает серию `ACK 0` (дубликаты игнорируются или учитываются для Fast Retransmit, в базовой версии игнорируются до тайм-аута).
8.  Sender: Timeout. Повторная отправка `[1, 2, 3, 4...]`.
9.  Receiver получает 1 -> `ACK 1`. Ждет 2.
10. Восстановление завершено.

---

## 6. Детали реализации и инструменты

*   **Язык:** C++ (Standard C++11).
*   **Сетевое API:** BSD Sockets (`sys/socket.h`, `netinet/in.h`).
*   **API Таймера:** `select()` c параметром `struct timeval`. Это позволяет реализовать цикл событий, который обрабатывает и приходящие пакеты (ACK), и истечение времени ожидания в одном потоке.
*   **Запуск:**
    *   `./rdt_sender <IP> <PORT> <FILE> [--loss 20] [-d]`
    *   `./rdt_receiver <PORT> <FILE> [-d]`
*   **Логирование:** Реализован флаг `-d` (debug), выводящий в консоль каждое событие (отправка, получение, отбрасывание, тайм-аут), что позволяет визуализировать работу алгоритма GBN.

---

## 7. Заключение

Разработанный протокол полностью удовлетворяет требованиям технического задания. Реализация Go-Back-N обеспечивает корректную доставку файлов любого типа (текстовые, бинарные) в условиях потери пакетов до 20-30% и более, жертвуя пропускной способностью ради надежности (за счет повторной передачи всего окна). Формат пакетов оптимизирован для передачи через UDP, а конечные автоматы гарантируют отсутствие тупиковых ситуаций (deadlocks).