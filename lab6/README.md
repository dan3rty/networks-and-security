# Простой Веб-сервер на C++ (Лабораторная работа)

Этот проект представляет собой простой HTTP/1.1 веб-сервер, написанный на C++ с использованием системных вызовов POSIX Sockets. Сервер способен обрабатывать `GET`-запросы, отдавать статические файлы из указанной директории и возвращать корректные HTTP-ответы (`200 OK` и `404 Not Found`).

## Документ по проектированию: Архитектура

### 1. Основная концепция

В основе архитектуры лежит объектно-ориентированный подход. Вся логика работы сервера инкапсулирована в классе `WebServer`. Этот класс отвечает за полный жизненный цикл сервера: от создания и настройки сокета до обработки клиентских соединений и корректного освобождения ресурсов.

Такой подход позволяет изолировать логику, упростить главный файл (`main.cpp`), а также делает код более читаемым, поддерживаемым и расширяемым в будущем.

### 2. Структура проекта

Проект имеет следующую логическую структуру:

-   `src/`: Директория с исходным кодом.
    -   `WebServer.h` / `WebServer.cpp`: Определение и реализация класса `WebServer`.
    -   `main.cpp`: Точка входа в программу. Создает и запускает экземпляр `WebServer`.
-   `public/`: Корневая директория (Document Root), содержащая статические файлы (`.html`, `.css` и т.д.), которые сервер будет отдавать клиентам.
-   `CMakeLists.txt`: Файл для автоматизации сборки проекта с помощью CMake. Он также настроен для копирования директории `public` в папку сборки, чтобы обеспечить корректную работу сервера после компиляции.

### 3. Класс `WebServer`

Ключевой компонент системы. Его основные обязанности:

-   **Инициализация**: В конструкторе принимаются порт и путь к корневой директории с файлами. Вызывается приватный метод `setupServerSocket()` для создания, привязки и перевода сокета в режим прослушивания.
-   **Основной цикл**: Метод `run()` запускает бесконечный цикл `while(true)`, в котором сервер ожидает и принимает новые клиентские соединения с помощью `accept()`.
-   **Обработка клиента**: Для каждого нового соединения вызывается метод `handleClientConnection()`, который выполняет следующие шаги:
    1.  Читает HTTP-запрос из сокета клиента (`read`).
    2.  Парсит первую строку запроса для извлечения пути к запрашиваемому файлу (`parseRequestPath`).
    3.  Формирует полный путь к файлу на диске.
    4.  Пытается открыть файл.
    5.  На основе результата формирует HTTP-ответ (`buildHttpResponse`):
        -   `200 OK` с содержимым файла, если он найден.
        -   `404 Not Found` с сообщением об ошибке, если файл отсутствует.
    6.  Отправляет сформированный ответ клиенту (`write`).
    7.  Закрывает клиентский сокет (`close`).

## Сборка и запуск

### Требования

-   **ОС**: Linux / macOS (или любая другая POSIX-совместимая система).
-   **Компилятор C++**: GCC (g++) или Clang.
-   **Система сборки**: CMake (версия 3.10 или выше).

### Инструкция по сборке

1.  Клонируйте репозиторий или откройте терминал в корневой папке проекта.
2.  Создайте директорию для сборки и перейдите в неё.
    ```bash
    mkdir build
    cd build
    ```
3.  Запустите CMake для генерации файлов сборки. Если вы находитесь в директории `build`, которая лежит рядом с `lab6`, команда будет `cmake ../lab6`. Если вы находитесь в корне проекта, то `cmake .`. Для простоты предположим, что вы находитесь в корне проекта:
    ```bash
    cmake . -B build 
    ```
4.  Скомпилируйте проект.
    ```bash
    cmake --build build
    ```
    Или, если вы находитесь внутри папки `build`:
    ```bash
    make
    ```
    После успешной сборки исполняемый файл `lab6` и скопированная папка `public` будут находиться в `build/lab6/`.

### Инструкция по запуску

1.  Перейдите в директорию с исполняемым файлом.
    ```bash
    cd build/lab6/
    ```
2.  Запустите сервер.
    ```bash
    ./lab6
    ```
3.  Вы увидите в консоли сообщения об успешной инициализации и прослушивании порта 8080.

### Проверка работы

1.  Откройте ваш веб-браузер.
2.  Перейдите по адресу `http://localhost:8080`. Вы должны увидеть содержимое файла `public/index.html`.
3.  Перейдите по ссылке на другую страницу или введите вручную `http://localhost:8080/another_page.html`.
4.  Попробуйте запросить несуществующий файл, например, `http://localhost:8080/non-existent.html`. Вы должны увидеть текстовое сообщение "File Not Found".
5.  В консоли, где запущен сервер, будет отображаться лог входящих запросов и отправленных ответов.