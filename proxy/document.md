# Документация к Лабораторной работе №14: Алгоритм кэширования HTTP Прокси-сервера

## 1. Введение

В рамках лабораторной работы разработан однопоточный HTTP прокси-сервер с возможностью персистентного кэширования данных на жестком диске.
**Основная цель алгоритма кэширования** — снижение нагрузки на сеть, уменьшение задержек при повторном доступе к ресурсам и экономия внешнего трафика.

Алгоритм реализует стратегию «Look-aside Cache» (Кэш на стороне): прокси сначала проверяет наличие копии данных локально, и только в случае отсутствия обращается к целевому веб-серверу.

---

## 2. Общая схема работы алгоритма

Процесс обработки каждого HTTP GET-запроса можно разделить на следующие этапы:

1.  **Парсинг запроса:** Извлечение целевого URL из заголовка клиента.
2.  **Идентификация ресурса:** Генерация уникального ключа (имени файла) на основе URL.
3.  **Поиск в кэше:** Проверка существования файла с таким именем в директории хранения.
4.  **Ветвление логики:**
    *   **Cache HIT (Попадание):** Данные читаются с диска и отправляются клиенту. Сетевое соединение с целевым сервером не устанавливается.
    *   **Cache MISS (Промах):** Устанавливается соединение с целевым сервером, данные скачиваются, проверяются на валидность и сохраняются на диск для будущих запросов.

---

## 3. Детальное описание реализации

### 3.1. Генерация ключа кэширования (Hashing)

URL-адреса содержат специальные символы (`/`, `:`, `?`, `&`), которые недопустимы или проблематичны в именах файлов файловой системы. Для решения этой проблемы используется хэширование.

*   **Входные данные:** Полный URL ресурса (например, `http://www.example.com/index.html`).
*   **Функция:** Стандартная хэш-функция `std::hash<std::string>` из библиотеки C++.
*   **Результат:** Уникальное числовое значение (например, `164982304912`), к которому добавляется расширение `.cache`.

**Фрагмент кода:**
```cpp
string get_cache_filename(const string& url) {
    hash<string> hasher;
    size_t hash = hasher(url);
    return string(CACHE_DIR) + to_string(hash) + ".cache";
}
```

### 3.2. Обработка попадания в кэш (Cache HIT)

При поступлении запроса сервер пытается открыть файл в режиме чтения (`ifstream`). Если файл успешно открыт:
1.  Выводится лог о попадании (`[LOG] Cache HIT`).
2.  Данные считываются блоками по 4 КБ.
3.  Считанные блоки немедленно отправляются в сокет клиента.
4.  Файл закрывается.

Преимущество: полное отсутствие сетевых задержек (Latency) до удаленного сервера.

### 3.3. Обработка промаха и фильтрация ответов (Cache MISS)

Если файл не найден, выполняется запрос к удаленному серверу. Ключевой особенностью реализации является **анализ заголовков ответа** перед записью.

Согласно техническому заданию, кэшировать ошибки (например, 404 Not Found или 500 Internal Server Error) нельзя.

**Алгоритм записи:**
1.  Устанавливается соединение с хостом.
2.  Отправляется запрос.
3.  При получении первого пакета данных анализируется HTTP-статус.
4.  **Условие кэширования:** Строка ответа должна содержать `HTTP/1.x 200`.
    *   **Если 200 OK:** Создается файл на диске (`ofstream`), данные записываются в него параллельно с отправкой клиенту.
    *   **Если не 200:** Данные просто транслируются клиенту (pass-through), файл на диске не создается.

**Фрагмент логики фильтрации:**
```cpp
if (response_head.find("HTTP/1.1 200") != string::npos || 
    response_head.find("HTTP/1.0 200") != string::npos) {
    is_cachable = true; // Разрешаем запись
} else {
    is_cachable = false; // Запрещаем запись (например, для 404)
}
```

---

## 4. Структура хранения данных

*   **Директория:** `./cache/` (создается автоматически при запуске).
*   **Формат файлов:** Бинарный (содержит как HTTP-заголовки, так и тело ответа). Это позволяет при отдаче из кэша возвращать клиенту корректные заголовки `Content-Type`, `Content-Length` и т.д., так как они были сохранены вместе с данными.
*   **Очистка:** В текущей базовой реализации очистка производится вручную или перезапуском с удалением папки. (TTL не реализован в рамках базового уровня).

---

## 5. Обработка исключительных ситуаций

В алгоритме предусмотрены следующие защитные механизмы:

1.  **Создание директории:** Перед работой проверяется наличие папки кэша через `stat() / mkdir()`.
2.  **Блокировка записи ошибок:** Как описано выше, страницы с ошибками 404/403/500 не засоряют дисковое пространство.
3.  **Потоковая передача:** Файлы не загружаются в оперативную память целиком. Чтение и запись происходят через буфер (4096 байт), что позволяет скачивать файлы любого размера (даже превышающие объем RAM), ограничиваясь лишь свободным местом на диске.

## 6. Заключение

Реализованный алгоритм обеспечивает надежное кэширование статического контента (HTML, изображения, CSS). Использование хэширования URL гарантирует уникальность имен файлов, а проверка HTTP-статуса предотвращает "отравление" кэша страницами с ошибками. Тестирование показало значительное ускорение загрузки страниц при повторных обращениях.